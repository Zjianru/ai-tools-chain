# Worklog — 2025-11-14

目标：从自定义 OpenSpec 方言切换到“官方 openspec CLI + orchestrator”模式，简化 /plan 流程并统一日志归档策略。

本次改动（摘要）
- 移除自定义 OpenSpec 解析
  - 删除 `bin/ai-tools.mjs` 中的 `parseOpenSpecYAML` 与 `ensureOpenSpecScaffold` 逻辑，不再从 `.ai-tools-chain/openspec/spec.yaml` 解析 plan。
  - 移除 `ai-tools spec:scaffold/spec:lint/spec:plan` 命令及 doctor 中对 `.ai-tools-chain/openspec/spec.yaml` 的强制检查。
- 重写 `/plan` 流程（围绕官方 openspec change）
  - 在 REPL 中，`/plan` 触发对话式问答：按 openspec 要求依次询问 Why / What Changes / Requirements / Targets / Risks / Acceptance。
  - 将回答生成 `openspec/changes/task-<taskId>/change.md`，并调用 `openspec validate --changes --json --no-interactive` 校验（输出写入 `.ai-tools-chain/tasks/<taskId>/logs/openspec/validate*.{json,log}`）。
  - 使用 `openspec show --type change task-<taskId>` 生成 Markdown 计划，写入 `.ai-tools-chain/tasks/<taskId>/plan.md`；尝试 `openspec show --json --type change task-<taskId>` 输出 JSON，落盘为 `plan.openspec.json`（失败不阻断）。
  - 更新任务 `meta.json` 的状态为 `plan`，不再自行为 guardrails/acceptance 造字段；这些信息由 openspec 文本/JSON 自身承载。
- 日志归档策略调整
  - 统一约定日志目录为 `.ai-tools-chain/tasks/<taskId>/logs/` 下的子目录（本次已在 openspec 分支使用 `logs/openspec/`）。
  - 将 `autoArchiveOldTasks` 改为：对完成超过 7 天的任务，打包 `tasks/<id>/logs/` 整目录为 `.ai-tools-chain/archives/<id>.tar.gz`，然后删除该任务的 `logs/` 目录。
- README 调整
  - 明确：官方 openspec CLI 是规划组件，我们只是 orchestrator；/plan 通过问答生成 change，并用 openspec show 导出 plan.md/plan.openspec.json 作为后续模型上下文。
  - 去掉“自定义 spec.yaml 结构”作为主规范来源的描述，改为重点描述 change 驱动的工作流。

已知后续工作
- Promptfoo：`
  - 固定从 `.ai-tools-chain/promptfoo/promptfooconfig.yaml` 调用 `npx promptfoo eval`，将结果 JSON 与日志写入 `logs/promptfoo/`，并基于 stats 的 failures/errors 作为 Gate。
- 模型调用：
  - 在 `/codegen`/`/review`/第二视角中，将 `plan.md + plan.openspec.json + transcript 末几轮 + diff/patch` 打包为统一 payload 交给 Claude Code / Copilot / Codex，内部仅做最小字段提取。
- 日志目录统一：
  - 将评测、second-opinion、provider 调用等日志迁移到 `logs/` 子目录结构中，便于归档与排查。

后续必做（本轮已完成事项标记）
- ✅ 将 `/codegen`、`/review`、`/eval`、`/accept` 的核心逻辑抽取到 `src/core/` 模块（`src/core/codegen.mjs`、`src/core/review.mjs`、`src/core/eval.mjs`、`src/core/accept.mjs`），仅负责任务状态流转与文件/Git/模型调用，不掺杂任何 readline/提示文案。
- ✅ 在 `src/cli/` 增加 `repl` 与 `pipeline` 封装（`src/cli/repl.mjs`、`src/cli/pipeline.mjs`），把交互式 REPL 与非交互式 pipeline 的流程控制集中到 CLI 层，`bin/ai-tools.mjs` 只保留命令注册与入口调用。
- ✅ 为 pipeline 增加机器可读的结果文件（`tasks/<taskId>/pipeline-result.json`），`playgrounds/scripts/e2e_openspec_pipeline.sh` 优先检查该 JSON 中 planning/codegen/commit 三个阶段的状态。
- ✅ 在规划阶段引入 `planning` 模型角色：`invokeRole("planning")` 生成结构化规划（含 draft_files），写入 `planning.ai.json` 和可选的 `plan.files.json`，再调用 `runPlanningWithInputs` + openspec CLI 生成最终 `plan.md`。
- ✅ `/plan` 默认走 AI 规划流程，失败时自动回退到原有的 6 问手动问答；`/codegen` 不再使用本地“占位内容”策略，也取消了 `src/Main.java` 的兜底生成——若无法从规划/plan.files.json 中解析出目标文件，codegen 直接失败并给出明确提示。 

后续增强（记录，不一定在本轮完成）
- codegen 摘要：当前已对新增文件按行数统计，对修改文件使用 `git diff --numstat` 统计增删行；未来在 `patch.json` 中支持 `op=delete` 时，需要在摘要中一并统计删除文件及其删除行数。
- 规划 JSON：在现有 schema 上逐步引入 `scope`/`non_goals`/`design`/`file_impacts`/`test_plan`/`open_questions` 等字段；确保 JSON→OpenSpec 映射在字段缺失时采取“有则用、无则跳过”的策略。

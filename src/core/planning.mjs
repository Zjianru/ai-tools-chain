import fs from "fs-extra";
import { readFileSync, writeFileSync, existsSync } from "fs";
import { resolve, dirname } from "path";
import { execa } from "execa";
import chalk from "chalk";
import { invokeRole } from "../models/broker.mjs";

export async function runPlanningWithInputs({ cwd, aiDir, tasksDir, taskId, metaPath, inputs, planning }) {
    const logsDir = resolve(tasksDir, taskId, "logs", "openspec");
    fs.ensureDirSync(logsDir);

    const { title, why, what, req, targets, risks, accept } = inputs;
    const changeId = `task-${taskId}`;
    const openspecRoot = aiDir;
    const changeDir = resolve(openspecRoot, "openspec", "changes", changeId);
    fs.ensureDirSync(changeDir);

    const titleText = title || `Task ${taskId}`;
    const changeMd = [
        "---",
        `id: ${changeId}`,
        `title: ${titleText}`,
        "owner: @you",
        "risk: medium",
        "---",
        "",
        "## Why",
        (why || "(待补充)"),
        "",
        "## What Changes",
        (what || "(待补充)"),
        "",
        "## Requirements",
        (req ? req.split(/[,，]/).map(s => s.trim()).filter(Boolean).map(s => `- ${s}`).join("\n") || "- (待补充)" : "- (待补充)"),
        "",
        "## Targets",
        (targets ? targets.split(/[,，]/).map(s => s.trim()).filter(Boolean).map(s => `- ${s}`).join("\n") || "- (待补充)" : "- (待补充)"),
        "",
        "## Risks and Mitigations",
        (risks || "(待补充)"),
        "",
        "## Acceptance",
        (accept ? accept.split(/[,，]/).map(s => s.trim()).filter(Boolean).map(s => `- ${s}`).join("\n") || "- (待补充)" : "- (待补充)"),
        ""
    ].join("\n");
    writeFileSync(resolve(changeDir, "change.md"), changeMd, "utf-8");

    const proposalPath = resolve(changeDir, "proposal.md");
    if (!existsSync(proposalPath)) {
        const proposal = [
            `# Proposal for ${changeId}`,
            "",
            "This proposal was generated by AI Tools Chain.",
            "See change.md for detailed Why/What/Requirements/Targets/Risks/Acceptance.",
            ""
        ].join("\n");
        writeFileSync(proposalPath, proposal, "utf-8");
    }

    const specsDir = resolve(changeDir, "specs", "task");
    fs.ensureDirSync(specsDir);

    const planningObj = planning || {};
    const reqObjs = Array.isArray(planningObj.requirements) ? planningObj.requirements : [];

    if (reqObjs.length) {
        const specLines = ["## ADDED Requirements", ""];
        for (const r of reqObjs) {
            const rid = r.id || "";
            const titleReq = r.title || r.shall || titleText || `Task ${taskId}`;
            const shall = r.shall || `The system SHALL satisfy requirement ${rid || titleReq}.`;
            specLines.push(`### Requirement: ${titleReq}${rid ? ` (ID: ${rid})` : ""}`);
            specLines.push("");
            specLines.push(`The system SHALL: ${shall}`);
            specLines.push("");
            const scenarios = Array.isArray(r.scenarios) ? r.scenarios : [];
            if (scenarios.length) {
                for (const sc of scenarios) {
                    const sName = sc.name || "Scenario";
                    const steps = Array.isArray(sc.steps) ? sc.steps : [];
                    specLines.push(`#### Scenario: ${sName}`);
                    if (steps.length) {
                        for (const st of steps) {
                            specLines.push(`- ${st}`);
                        }
                    } else {
                        specLines.push("- (steps TBD)");
                    }
                    specLines.push("");
                }
            } else {
                specLines.push("#### Scenario: basic usage");
                specLines.push("- (scenario details TBD)");
                specLines.push("");
            }
        }
        const specMd = specLines.join("\n");
        writeFileSync(resolve(specsDir, "spec.md"), specMd, "utf-8");
    } else {
        const reqList = (req || "").split(/[,，]/).map(s => s.trim()).filter(Boolean);
        const primaryReq = reqList[0] || titleText || `Task ${taskId}`;
        const specMd = [
            "## ADDED Requirements",
            "",
            `### Requirement: ${primaryReq}`,
            "",
            `The system SHALL: ${primaryReq || "satisfy this autogenerated requirement."}`,
            "",
            "#### Scenario: basic usage",
            "- This scenario was generated by AI Tools Chain.",
            "- See change.md for full context and details.",
            ""
        ].join("\n");
        writeFileSync(resolve(specsDir, "spec.md"), specMd, "utf-8");
    }

    const tasksPath = resolve(changeDir, "tasks.md");
    if (!existsSync(tasksPath)) {
        const tasksList = Array.isArray(planningObj.tasks) && planningObj.tasks.length
            ? planningObj.tasks
            : [
                "Implement the changes described in change.md.",
                "Add or update tests to cover requirements and scenarios.",
                "Run the evaluation pipeline and ensure it passes."
            ];
        const lines = ["# Tasks", ""];
        tasksList.forEach((t, idx) => {
            lines.push(`${idx + 1}. ${t}`);
        });
        lines.push("");
        const tasksMd = lines.join("\n");
        writeFileSync(tasksPath, tasksMd, "utf-8");
    }

    try {
        const { stdout: vout, stderr: verr } = await execa("openspec", ["validate", "--changes", "--json", "--no-interactive"], { cwd: openspecRoot });
        writeFileSync(resolve(logsDir, "validate.json"), vout || "{}", "utf-8");
        if (verr) writeFileSync(resolve(logsDir, "validate.log"), verr, "utf-8");
    } catch (e) {
        const msg = e?.stdout || e?.stderr || e?.message || String(e);
        writeFileSync(resolve(logsDir, "validate.error.log"), String(msg), "utf-8");
        console.log(chalk.red("openspec validate 失败："), chalk.gray(String(msg).slice(0, 400)));
    }

    try {
        const { stdout } = await execa("openspec", ["show", "--type", "change", changeId], { cwd: openspecRoot });
        const planFile = resolve(tasksDir, taskId, "plan.md");
        writeFileSync(planFile, stdout || "", "utf-8");
        writeFileSync(resolve(logsDir, "show.md.log"), stdout || "", "utf-8");
    } catch (e) {
        const msg = e?.stdout || e?.stderr || e?.message || String(e);
        writeFileSync(resolve(logsDir, "show-md.error.log"), String(msg), "utf-8");
        console.log(chalk.red("openspec show (markdown) 失败："), chalk.gray(String(msg).slice(0, 400)));
    }

    const meta = JSON.parse(readFileSync(metaPath, "utf-8"));
    meta.status = "plan";
    writeFileSync(metaPath, JSON.stringify(meta, null, 2));
}

export function ensurePlanningDraft({ tasksDir, taskId }) {
    const taskDir = resolve(tasksDir, taskId);
    fs.ensureDirSync(taskDir);
    const draftPath = resolve(taskDir, "planning.draft.json");
    if (!existsSync(draftPath)) {
        const draft = {
            schema_version: 1,
            meta: {},
            why: "",
            what: "",
            requirements: [],
            targets: [],
            risks: [],
            acceptance: [],
            draft_files: [],
            tasks: [],
            notes: ""
        };
        writeFileSync(draftPath, JSON.stringify(draft, null, 2), "utf-8");
        return draft;
    }
    try {
        const raw = readFileSync(draftPath, "utf-8");
        return JSON.parse(raw);
    } catch {
        // 若解析失败，以空草案重建，避免阻断后续流程
        const draft = {
            schema_version: 1,
            meta: {},
            why: "",
            what: "",
            requirements: [],
            targets: [],
            risks: [],
            acceptance: [],
            draft_files: [],
            tasks: [],
            notes: ""
        };
        try {
            writeFileSync(draftPath, JSON.stringify(draft, null, 2), "utf-8");
        } catch {
            // best-effort
        }
        return draft;
    }
}

export function writePlanningDraft({ tasksDir, taskId, planning }) {
    const taskDir = resolve(tasksDir, taskId);
    fs.ensureDirSync(taskDir);
    const draftPath = resolve(taskDir, "planning.draft.json");
    writeFileSync(draftPath, JSON.stringify(planning, null, 2), "utf-8");
}

export async function callPlanningOnce({
    cwd,
    aiDir,
    tasksDir,
    taskId,
    userBrief,
    history = [],
    round = 1,
    draft = null
}) {
    const taskDir = resolve(tasksDir, taskId);
    fs.ensureDirSync(taskDir);

    let repoSummary = "";
    try {
        const { stdout } = await execa("git", ["ls-files"], { cwd });
        const files = stdout.split(/\r?\n/).filter(Boolean);
        repoSummary = files.slice(0, 100).join("\n");
    } catch {
        repoSummary = "";
    }

    const planningRes = await invokeRole(
        "planning",
        { userBrief, repoSummary, history, draft },
        { aiDir, cwd }
    );
    if (!planningRes?.ok) {
        throw new Error(planningRes?.error || "planning 调用失败");
    }

    // 记录 AI 调用日志和 token 使用情况（每轮一个文件）
    try {
        const logsDir = resolve(tasksDir, taskId, "logs", "models");
        fs.ensureDirSync(logsDir);
        const log = {
            role: "planning",
            provider: "deepseek",
            model: planningRes.raw?.model || "",
            round,
            created_at: new Date().toISOString(),
            user_brief: userBrief,
            repo_summary_sample: repoSummary.slice(0, 400),
            history,
            usage: planningRes.usage || null
        };
        writeFileSync(resolve(logsDir, `planning.deepseek.${round}.json`), JSON.stringify(log, null, 2), "utf-8");
    } catch {
        // logging best-effort
    }

    return planningRes;
}

export async function applyPlanningAndOpenSpec({ cwd, aiDir, tasksDir, taskId, metaPath, planning }) {
    const taskDir = resolve(tasksDir, taskId);
    fs.ensureDirSync(taskDir);

    const planningPath = resolve(taskDir, "planning.ai.json");
    writeFileSync(planningPath, JSON.stringify(planning, null, 2), "utf-8");
    const title = planning.title || `Task ${taskId}`;
    const why = planning.why || "";
    const what = planning.what || "";
    const requirements = Array.isArray(planning.requirements) ? planning.requirements : [];
    const targets = Array.isArray(planning.targets) ? planning.targets : [];
    const acceptance = Array.isArray(planning.acceptance) ? planning.acceptance : [];
    const risks = planning.risks || "";

    const inputs = {
        title,
        why,
        what,
        req: requirements.join(","),
        targets: targets.join(","),
        risks,
        accept: acceptance.join(",")
    };

    if (Array.isArray(planning.draft_files) && planning.draft_files.length) {
        const filesJsonPath = resolve(taskDir, "plan.files.json");
        writeFileSync(filesJsonPath, JSON.stringify({ files: planning.draft_files }, null, 2), "utf-8");
    }

    await runPlanningWithInputs({ cwd, aiDir, tasksDir, taskId, metaPath, inputs, planning });
}

// 保留单次 AI 规划 + OpenSpec 的封装，供非交互式场景复用
export async function runAIPlanningAndOpenSpec({ cwd, aiDir, tasksDir, taskId, metaPath, userBrief }) {
    const res = await callPlanningOnce({ cwd, aiDir, tasksDir, taskId, userBrief, history: [], round: 1 });
    if (!res.planning) {
        throw new Error(res.error || "planning 未返回规划结果");
    }
    await applyPlanningAndOpenSpec({ cwd, aiDir, tasksDir, taskId, metaPath, planning: res.planning });
}
